# Phase 4: Web UI — `st web`

Browser-based dashboard for smoovtask. Kanban board, list view, ticket detail with rendered markdown, live activity feed via SSE. Single binary, no external dependencies at runtime.

## Tech Choices

| Component | Choice | Why |
|-----------|--------|-----|
| Templates | [templ](https://github.com/a-h/templ) | Type-safe Go templates, compile-time error checking. Generates `*_templ.go` files. |
| CSS/JS | Vendored + `go:embed` | Single binary distribution. No CDN, works offline. |
| Styling | [Franken UI](https://franken-ui.dev/) 2.0 | UIKit component library rebuilt on Tailwind. Dark theme by default. |
| Interactivity | [htmx](https://htmx.org/) 2.0.4 + SSE extension 2.2.2 | Partial HTML swaps, SSE-driven live updates. No JS framework needed. |
| Markdown | [goldmark](https://github.com/yuin/goldmark) | Standard Go markdown-to-HTML renderer for ticket bodies. |
| Router | `net/http` (Go 1.22+) | `mux.HandleFunc("GET /path", handler)` — no extra dependency. |
| SSE | [fsnotify](https://github.com/fsnotify/fsnotify) + fan-out broker | Watches JSONL events dir, pushes new events to all connected browsers. |

## Dependencies Added

```
github.com/a-h/templ        v0.3.977
github.com/yuin/goldmark     v1.7.16
github.com/fsnotify/fsnotify v1.9.0
```

Vendored static assets (committed, not Go deps):
- `htmx.min.js` — 51KB
- `htmx-sse.min.js` — 9KB
- `frankenui.min.css` — 175KB
- `frankenui.min.js` — 221KB

## Package Structure

```
cmd/web.go                              # Cobra command: st web [--port 8080]

internal/web/
├── server.go                           # Server struct, route registration, graceful shutdown
├── handler/
│   ├── handler.go                      # Handler struct, shared helpers (groupByStatus, recentEvents, uniqueProjects)
│   ├── board.go                        # GET /           — kanban board
│   ├── list.go                         # GET /list       — filterable list view
│   ├── ticket.go                       # GET /ticket/{id} — ticket detail with goldmark rendering
│   ├── activity.go                     # GET /activity   — event feed with filters
│   ├── events.go                       # GET /events     — SSE endpoint
│   └── handler_test.go                 # 13 tests (httptest)
├── sse/
│   ├── broker.go                       # Fan-out: subscribe/unsubscribe/broadcast to client channels
│   └── watcher.go                      # fsnotify on events dir, reads new JSONL lines, feeds broker
├── static/
│   ├── embed.go                        # go:embed dist/*
│   └── dist/
│       ├── htmx.min.js
│       ├── htmx-sse.min.js
│       ├── frankenui.min.css
│       └── frankenui.min.js
└── templates/
    ├── layout.templ                    # HTML shell: head, nav bar, content slot, dark theme
    ├── components.templ                # TicketCard, PriorityBadge, StatusBadge
    ├── board.templ                     # Kanban columns grouped by status
    ├── list.templ                      # Table with project/status filter dropdowns
    ├── ticket.templ                    # Detail page: rendered body + metadata sidebar
    ├── activity.templ                  # Event feed with project/type filters
    └── *_templ.go                      # Generated by templ (6 files)
```

## Routes

| Method | Path | Handler | Response |
|--------|------|---------|----------|
| GET | `/` | `Board` | Full page — kanban board with all tickets grouped by status |
| GET | `/list` | `List` | Full page — table view, filterable by project and status |
| GET | `/ticket/{id}` | `Ticket` | Full page — ticket detail with goldmark-rendered markdown body |
| GET | `/activity` | `Activity` | Full page — recent events, filterable by project and event type |
| GET | `/events` | `Events` | SSE stream — pushes `refresh` events when JSONL files change |
| GET | `/static/*` | `FileServer` | Embedded static assets (htmx, Franken UI) |
| GET | `/partials/board` | `PartialBoard` | HTML fragment — board content only (for htmx swap) |
| GET | `/partials/list` | `PartialList` | HTML fragment — list content only (for htmx swap) |
| GET | `/partials/ticket/{id}` | `PartialTicket` | HTML fragment — ticket content only (for htmx swap) |

Every full page has a corresponding `/partials/*` endpoint that returns just the content without the `<html>` shell. htmx uses these for live updates and filter changes.

## How SSE Live Updates Work

```
JSONL files on disk (appended by st CLI commands)
       │
       ▼
watcher.go
  │  fsnotify watches ~/.smoovtask/events/
  │  On file write/create:
  │    - Seeks to last known offset
  │    - Reads new lines
  │    - JSON-decodes each line to event.Event
  │    - Calls broker.Broadcast(event)
  ▼
broker.go
  │  Maintains map[chan event.Event]struct{} of subscribers
  │  Broadcast sends to all channels (drops if buffer full)
  ▼
/events SSE endpoint (handler/events.go)
  │  Per-client goroutine
  │  Subscribes to broker on connect, unsubscribes on disconnect
  │  Writes: "event: refresh\ndata: {json}\n\n"
  ▼
htmx SSE extension on client
  │  <div hx-ext="sse" sse-connect="/events" sse-swap="refresh"
  │       hx-get="/partials/board" hx-trigger="sse:refresh"
  │       hx-target="#board" hx-swap="innerHTML">
  │
  │  On receiving "refresh" event → fetches partial HTML → swaps into DOM
  ▼
Browser shows updated content without page reload
```

The SSE stream sends lightweight JSON event notifications. The client uses htmx to re-fetch the relevant partial (board, list, ticket) rather than receiving full HTML over SSE. This keeps SSE payloads small and reuses the same templ templates for both initial render and live updates.

### Offset Tracking

The watcher snapshots all existing JSONL file sizes on startup, so it only streams events that arrive *after* the server starts. This prevents flooding connected clients with historical data. New files (next day's JSONL rotation) are detected via fsnotify `Create` events.

### Backpressure

Each subscriber channel has a buffer of 64 events. If a slow client can't keep up, events are dropped with a warning log rather than blocking the broadcaster.

## Handler Details

### Board (`handler/board.go`)

Loads all tickets via `store.List(ListFilter{})`, groups them by status using `groupByStatus()`, and arranges columns in workflow order:

```
BACKLOG → OPEN → IN-PROGRESS → REVIEW → REWORK → BLOCKED → DONE
```

Each column shows a count badge and renders `TicketCard` components. Empty columns show "No tickets" placeholder text.

### List (`handler/list.go`)

Loads tickets with optional `?project=` and `?status=` query params passed to `store.List(ListFilter{})`. Collects unique project names from all tickets for the filter dropdown. Table rows are clickable (via `data-href` attribute + delegated click handler in layout).

The filter dropdowns use htmx: changing a select triggers `hx-get="/partials/list"` with `hx-include` to send sibling select values as query params. The partial replaces just the table content.

### Ticket (`handler/ticket.go`)

Loads ticket by ID from path (`r.PathValue("id")`), renders the markdown body to HTML via goldmark, and passes both to the template. The template renders:

- **Main area**: Title, ID/status/priority badges, rendered markdown body
- **Sidebar**: Status, priority, project, assignee, created/updated timestamps, tags, dependency links

Returns 404 if ticket ID not found.

### Activity (`handler/activity.go`)

Queries the last 200 events via `event.QueryEvents()`, reverses to newest-first order. Supports filtering by:

- `?project=` — passed directly to `event.Query.Project`
- `?event_type=` — prefix filter (`ticket.`, `status.`, `hook.`)

### Events SSE (`handler/events.go`)

Sets SSE headers (`Content-Type: text/event-stream`, `Cache-Control: no-cache`, etc.), subscribes to the broker, sends initial keepalive comment, then loops reading from the channel until client disconnects (`r.Context().Done()`).

## Template Architecture

All templates use the `templates` package and follow this pattern:

- **`Layout(title, currentPath)`** — wraps all full pages. Takes `children...` slot. Includes Franken UI CSS/JS, htmx, SSE extension, custom styles, nav bar with active state.
- **`*Page(data)`** — full page templates that wrap content in `Layout` and set up SSE connection attributes.
- **`*Content(data)`** — inner content templates rendered by both full pages and partials. This is what gets swapped by htmx.

### Component Templates

- **`TicketCard(tk)`** — compact card with title, priority badge, ID, project. Links to `/ticket/{id}`.
- **`PriorityBadge(p)`** — colored badge (P0=red, P1=orange, P2=amber, P3=blue, P4=gray, P5=dark gray).
- **`StatusBadge(s)`** — outlined badge with status-specific border color.

## Server Lifecycle

```go
// cmd/web.go
ctx, stop := signal.NotifyContext(context.Background(), SIGINT, SIGTERM)
srv := web.NewServer(cfg, webPort)
srv.ListenAndServe(ctx)
```

`ListenAndServe`:
1. Resolves events and tickets directories from config
2. Starts SSE broker (in-memory)
3. Starts fsnotify watcher on events dir
4. Registers all routes on `http.ServeMux`
5. Spawns goroutine that waits for context cancellation → calls `srv.Shutdown(5s timeout)`
6. Calls `http.Server.ListenAndServe`
7. On shutdown: watcher closes (stops fsnotify), broker clients get channel close, HTTP connections drain

## Styling

Dark theme by default (`<html class="dark">`). Custom CSS classes prefixed with `st-` to avoid conflicts with Franken UI:

- `.st-board` — flex container for kanban columns
- `.st-column` / `.st-column-header` — individual columns with status-colored borders
- `.st-card` — ticket card with hover effect
- `.st-badge` / `.st-badge-p0` through `.st-badge-p5` — priority color coding
- `.st-status-*` — border colors matching workflow statuses
- `.st-event-row` / `.st-event-type` / `.st-event-time` — activity feed rows
- `.st-ticket-body` — markdown content styling (headings, code, lists)
- `.st-sidebar-*` — ticket detail sidebar items
- `.st-nav-active` — active nav item highlight

## Tests

All in `internal/web/handler/handler_test.go` (13 tests):

| Test | What it verifies |
|------|-----------------|
| `TestBoard` | Full board page renders with ticket titles and layout |
| `TestPartialBoard` | Partial returns board HTML without `<!DOCTYPE>` wrapper |
| `TestList` | List page contains all ticket IDs |
| `TestListFilterByStatus` | `?status=OPEN` includes OPEN tickets, excludes IN-PROGRESS |
| `TestTicket` | Detail page renders title and goldmark `**bold**` → `<strong>` |
| `TestTicketNotFound` | Returns 404 for nonexistent ticket ID |
| `TestActivity` | Activity page contains `ticket.created` event type |
| `TestActivityFilterByProject` | `?project=testproj` excludes other project events |
| `TestEvents` | SSE endpoint sends keepalive comment |
| `TestSSEBrokerBroadcast` | Broadcast delivers event to subscribed channel |
| `TestSSEBrokerMultipleClients` | Broadcast reaches all subscribers |
| `TestSSEBrokerUnsubscribe` | Unsubscribe removes client, count decrements |
| `TestWatcher` | Writing JSONL file triggers broadcast to subscriber |

Test setup creates temp directories, two test tickets (OPEN + IN-PROGRESS), and one test event, then constructs a `Handler` with a real `ticket.Store` and `sse.Broker`.

## Justfile Recipes Added

```just
# Generate templ templates
templ:
    templ generate ./internal/web/templates/

# Build now depends on templ generation
build: templ
    go build -o st ./cmd/st
    go install ./cmd/st

# Dev server with templ hot reload
dev-web:
    templ generate --watch --proxy="http://localhost:8080" --cmd="go run ./cmd/st web" ./internal/web/templates/
```

## Files Modified (Existing)

| File | Change |
|------|--------|
| `go.mod` | Added templ, goldmark, fsnotify |
| `go.sum` | Updated |
| `justfile` | Added `templ`, `dev-web` recipes; `build` depends on `templ` |

## Usage

```sh
# Start the web server
st web                    # default port 8080
st web --port 3000        # custom port

# Dev mode with hot reload
just dev-web

# Build (includes templ generate)
just build
```

Browse to `http://localhost:8080`:
- `/` — Kanban board
- `/list` — Filterable list view
- `/ticket/{id}` — Ticket detail with rendered markdown
- `/activity` — Live event feed

Open the board in a browser, then run CLI commands (`st status review`, `st note "..."`, etc.) in a terminal — the board updates in real-time via SSE.
